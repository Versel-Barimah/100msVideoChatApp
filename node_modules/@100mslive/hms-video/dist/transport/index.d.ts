import ITransportObserver from './ITransportObserver';
import ITransport from './ITransport';
import { HMSLocalTrack } from '../media/tracks';
import { HMSVideoTrackSettings, HMSAudioTrackSettings } from '../media/settings';
import { HMSPeer, HMSRoleChangeRequest, HLSConfig } from '../interfaces';
import { IStore } from '../sdk/store';
import { DeviceManager } from '../device-manager';
import { MultiTrackUpdateRequestParams, TrackUpdateRequestParams } from '../signal/interfaces';
import Message from '../sdk/models/HMSMessage';
import { RTMPRecordingConfig } from '../interfaces/rtmp-recording-config';
import { LocalTrackManager } from '../sdk/LocalTrackManager';
import { HMSWebrtcInternals } from '../rtc-stats/HMSWebrtcInternals';
import { EventBus } from '../events/EventBus';
export default class HMSTransport implements ITransport {
    private observer;
    private deviceManager;
    private store;
    private localTrackManager;
    private eventBus;
    private state;
    private trackStates;
    private publishConnection;
    private subscribeConnection;
    private initConfig?;
    private endpoint;
    private joinParameters?;
    private retryScheduler;
    private trackDegradationController?;
    private webrtcInternals?;
    constructor(observer: ITransportObserver, deviceManager: DeviceManager, store: IStore, localTrackManager: LocalTrackManager, eventBus: EventBus);
    /**
     * Map of callbacks used to wait for an event to fire.
     * Used here for:
     *  1. publish/unpublish waits for [IPublishConnectionObserver.onRenegotiationNeeded] to complete
     */
    private readonly callbacks;
    private signalObserver;
    private signal;
    private analyticsSignalTransport;
    private publishConnectionObserver;
    private subscribeConnectionObserver;
    getLocalScreen(videoSettings: HMSVideoTrackSettings, audioSettings: HMSAudioTrackSettings): Promise<Array<HMSLocalTrack>>;
    getWebrtcInternals(): HMSWebrtcInternals | undefined;
    join(authToken: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, initEndpoint?: string, autoSubscribeVideo?: boolean): Promise<void>;
    connect(token: string, endpoint: string, peerId: string): Promise<void>;
    leave(): Promise<void>;
    publish(tracks: Array<HMSLocalTrack>): Promise<void>;
    unpublish(tracks: Array<HMSLocalTrack>): Promise<void>;
    sendMessage(message: Message): Promise<void>;
    /**
     * TODO: check if track.publishedTrackId be used instead of the hack to match with track with same type and
     * source. The hack won't work if there are multiple tracks with same source and type.
     */
    trackUpdate(track: HMSLocalTrack): void;
    changeRole(forPeer: HMSPeer, toRole: string, force?: boolean): Promise<void>;
    acceptRoleChange(request: HMSRoleChangeRequest): Promise<void>;
    endRoom(lock: boolean, reason: string): Promise<void>;
    removePeer(peerId: string, reason: string): Promise<void>;
    startRTMPOrRecording(params: RTMPRecordingConfig): Promise<void>;
    stopRTMPOrRecording(): Promise<void>;
    startHLSStreaming(params: HLSConfig): Promise<void>;
    stopHLSStreaming(params?: HLSConfig): Promise<void>;
    changeName(name: string): Promise<void>;
    changeMetadata(metadata: string): Promise<void>;
    changeTrackState(trackUpdateRequest: TrackUpdateRequestParams): Promise<void>;
    changeMultiTrackState(trackUpdateRequest: MultiTrackUpdateRequestParams): Promise<void>;
    private publishTrack;
    private unpublishTrack;
    private connectionJoin;
    private performPublishRenegotiation;
    private handleIceConnectionFailure;
    private internalConnect;
    private openSignal;
    private initRtcStatsMonitor;
    private retryPublishIceFailedTask;
    private retrySubscribeIceFailedTask;
    private retrySignalDisconnectTask;
    private setTransportStateForJoin;
}
